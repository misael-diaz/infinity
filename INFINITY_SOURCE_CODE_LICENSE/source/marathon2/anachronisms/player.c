/*PLAYER.CSaturday, December 11, 1993 10:25:55 AMFriday, September 30, 1994 5:48:25 PM (Jason)	moved nearly all sounds out of the damage_definition structure and into shapes.Wednesday, October 26, 1994 3:18:59 PM (Jason)	invincible players are now damaged by fusion projectiles.Wednesday, November 30, 1994 6:56:20 PM  (Jason)	oxygen is used up faster by running and by firing.Thursday, January 12, 1995 11:18:18 AM  (Jason')	dead players don’t continue to use up oxygen.Thursday, July 6, 1995 4:53:52 PM	supports multi-player cooperative games. (Ryan)*/#include "cseries.h"#include "map.h"#include "player.h"#include "monsters.h"#include "interface.h"#include "sound.h"#include "fades.h"#include "media.h"#include "items.h"#include "weapons.h"#include "game_window.h"#include "computer_interface.h"/*//anybody on the receiving pad of a teleport should explode (what happens to invincible guys?)// Really should create a function that initializes the player state.??new players should teleport in*/#include <string.h>#ifdef mpwc#pragma segment player#endif/* ---------- constants */#define ACTION_QUEUE_BUFFER_DIAMETER 0x100#define ACTION_QUEUE_BUFFER_INDEX_MASK 0xff#define kINVISIBILITY_DURATION (70*TICKS_PER_SECOND)#define kINVINCIBILITY_DURATION (50*TICKS_PER_SECOND)#define kEXTRAVISION_DURATION (3*TICKS_PER_MINUTE)#define kINFRAVISION_DURATION (3*TICKS_PER_MINUTE)#define MINIMUM_REINCARNATION_DELAY (TICKS_PER_SECOND)#define NORMAL_REINCARNATION_DELAY (10*TICKS_PER_SECOND)#define SUICIDE_REINCARNATION_DELAY (15*TICKS_PER_SECOND)#define DEAD_PLAYER_HEIGHT WORLD_ONE_FOURTH#define OXYGEN_WARNING_LEVEL TICKS_PER_MINUTE#define OXYGEN_WARNING_FREQUENCY (TICKS_PER_MINUTE/4)#define OXYGEN_WARNING_OFFSET (10*TICKS_PER_SECOND)#define LAST_LEVEL 100				/* ---------- structures */struct action_queue /* 8 bytes */{	short read_index, write_index;		long *buffer;};struct player_shape_definitions{	short collection;	short dying_hard, dying_soft;	short dead_hard, dead_soft;	short legs[NUMBER_OF_PLAYER_ACTIONS]; /* stationary, walking, running, sliding, airborne */	short torsos[PLAYER_TORSO_SHAPE_COUNT]; /* NONE, ..., double pistols */	short charging_torsos[PLAYER_TORSO_SHAPE_COUNT]; /* NONE, ..., double pistols */	short firing_torsos[PLAYER_TORSO_SHAPE_COUNT]; /* NONE, ..., double pistols */};struct damage_response_definition{	short type;	short damage_threshhold; /* NONE is none, otherwise bumps fade by one if over threshhold */		short fade;	short sound, death_sound;};/* ---------- globals */#ifdef DEMOstruct player_data players[MAXIMUM_NUMBER_OF_PLAYERS];#elsestruct player_data *players;#endifstruct player_data *local_player, *current_player;short local_player_index, current_player_index;static struct action_queue *action_queues;static struct player_shape_definitions player_shapes={	6, /* collection */		9, 8, /* dying hard, dying soft */	11, 10, /* dead hard, dead soft */	{7, 0, 0, 24, 23}, /* legs: stationary, walking, running, sliding, airborne */	{1, 3, 20, 26, 14, 12, 12, 16, 5, 18, 29}, /* idle torsos: fists, magnum, fusion, assault, rocket, flamethrower, alien, shotgun, double pistol, double shotgun, da ball */	{1, 3, 21, 26, 14, 12, 12, 16, 5, 18, 29}, /* charging torsos: fists, magnum, fusion, assault, rocket, flamethrower, alien, shotgun, double pistol, double shotgun, ball */	{2, 4, 22, 27, 15, 13, 13, 17, 6, 19, 29}, /* firing torsos: fists, magnum, fusion, assault, rocket, flamethrower, alien, shotgun, double pistol, double shotgun, ball */};/* Add to this as you will.. */static short player_initial_start_items[]= { 	_i_magnum,  // First weapon is the weapon he will use...	_i_knife,	_i_knife,	_i_magnum_magazine, 	_i_magnum_magazine,#if 0	_i_assault_rifle, 	_i_magnum, 	_i_missile_launcher, 	_i_flamethrower,	_i_plasma_pistol, //	_i_alien_shotgun, //	_i_shotgun,	_i_assault_rifle_magazine, 	_i_assault_grenade_magazine, 	_i_magnum_magazine, 	_i_missile_launcher_magazine, 	_i_flamethrower_canister,	_i_plasma_magazine, //	_i_shotgun_magazine, //	_i_shotgun,#endif	_i_magnum_magazine};	#define NUMBER_OF_DAMAGE_RESPONSE_DEFINITIONS (sizeof(damage_response_definitions)/sizeof(struct damage_response_definition))static struct damage_response_definition damage_response_definitions[]={	{_damage_explosion, 100, _fade_yellow, NONE, NONE},	{_damage_crushing, NONE, _fade_red, NONE, NONE},	{_damage_projectile, NONE, _fade_red, NONE, NONE},	{_damage_electrical_staff, NONE, _fade_cyan, NONE, NONE},	{_damage_hulk_slap, NONE, _fade_cyan, NONE, NONE},	{_damage_absorbed, 100, _fade_white, _snd_absorbed, NONE},	{_damage_teleporter, 100, _fade_white, _snd_absorbed, NONE},	{_damage_flame, NONE, _fade_orange, NONE, NONE},	{_damage_hound_claws, NONE, _fade_red, NONE, NONE},	{_damage_compiler_bolt, NONE, _fade_static, NONE, NONE},	{_damage_alien_projectile, NONE, _fade_dodge_purple, NONE, NONE},	{_damage_hunter_bolt, NONE, _fade_burn_green, NONE, NONE},	{_damage_fusion_bolt, 60, _fade_negative, NONE, NONE},	{_damage_fist, 40, _fade_red, NONE, NONE},	{_damage_armageddon_electricity, NONE, _fade_burn_cyan, NONE, NONE},	{_damage_armageddon_sphere, NONE, _fade_dodge_yellow, NONE, NONE},	{_damage_wasp, NONE, _fade_purple, NONE, NONE},	{_damage_lava, NONE, _fade_long_orange, NONE, NONE},	{_damage_goo, NONE, _fade_long_green, NONE, NONE},	{_damage_suffocation, NONE, NONE, NONE, NONE},	{_damage_energy_drain, NONE, NONE, NONE, NONE},	{_damage_oxygen_drain, NONE, NONE, NONE, NONE},	{_damage_hummer_bolt, NONE, _fade_flicker_negative, NONE, NONE}};/* For teleportation */#define EPILOGUE_LEVEL_NUMBER 256#define NO_TELEPORTATION_DESTINATION 512/* ---------- private prototypes */static void set_player_shapes(short player_index, boolean animate);static void revive_player(short player_index);static void recreate_player(short player_index);static void kill_player(short player_index, short aggressor_player_index, short action);static void give_player_initial_items(short player_index);static void get_player_transfer_mode(short player_index, short *transfer_mode, short *transfer_period);static void set_player_dead_shape(short player_index, boolean dying);static void burn_players_items(short player_index);static void update_player_teleport(short player_index);static void handle_player_in_vacuum(short player_index, long action_flags);static void update_player_media(short player_index);static short calculate_player_team(short base_team);static void drop_the_ball(short player_index);#if 0static serial_number_validity_check(void);#endif/* ---------- code */void allocate_player_memory(	void){	long *action_queue_buffer;	short i;#ifndef DEMO		/* allocate space for all our players */	players= (struct player_data *) malloc(sizeof(struct player_data)*MAXIMUM_NUMBER_OF_PLAYERS);	assert(players);#endif#ifdef BETA	dprintf("#%d players at %p (%x bytes each) ---------------------------------------;g;", MAXIMUM_NUMBER_OF_PLAYERS, players, sizeof(struct player_data));#endif	/* allocate space for our action queue headers and the queues themselves */	action_queues= (struct action_queue *) malloc(sizeof(struct action_queue)*MAXIMUM_NUMBER_OF_PLAYERS);	action_queue_buffer= (long *) malloc(sizeof(long)*MAXIMUM_NUMBER_OF_PLAYERS*ACTION_QUEUE_BUFFER_DIAMETER);	assert(action_queues&&action_queue_buffer);		/* tell the queues where their buffers are */	for (i=0;i<MAXIMUM_NUMBER_OF_PLAYERS;++i)	{		action_queues[i].buffer= action_queue_buffer + i*ACTION_QUEUE_BUFFER_DIAMETER;	}	return;}/* returns player index */short new_player(	short team,	short color,	short identifier){	short player_index, loop;	struct player_data *player;	/* find a free slot */	player_index= dynamic_world->player_count;	assert(player_index<MAXIMUM_NUMBER_OF_PLAYERS);	dynamic_world->player_count += 1;	player= get_player_data(player_index);	/* and initialize it */	memset(player, 0, sizeof(struct player_data));	player->teleporting_destination= NO_TELEPORTATION_DESTINATION;	player->interface_flags= 0; // Doesn't matter-> give_player_initial_items will take care of it.	player->suit_energy= PLAYER_MAXIMUM_SUIT_ENERGY;	player->suit_oxygen= PLAYER_MAXIMUM_SUIT_OXYGEN;	player->color= color;	player->team= team;	player->flags= 0;		player->invincibility_duration= 0;	player->invisibility_duration= 0;	player->infravision_duration= 0;	player->extravision_duration= 0;	player->identifier= identifier;	/* initialize inventory */		for (loop=0;loop<NUMBER_OF_ITEMS;++loop) player->items[loop]= NONE;	/* create the player.. */	recreate_player(player_index);	/* Mark the player's inventory as dirty */	mark_player_inventory_as_dirty(player_index, NONE);	initialize_player_weapons(player_index);#if 0	if (get_game_status()==game_in_progress) serial_number_validity_check();#endif		/* give the player his initial items */	if (GET_GAME_OPTIONS()&_burn_items_on_death) give_player_initial_items(player_index);	return player_index;}void walk_player_list(	void){	struct player_data *player;	short player_index= current_player_index;		/* find the next player in the list we can look at and switch to them */	do	{		if ((player_index+= 1)>=dynamic_world->player_count) player_index= 0;		player= get_player_data(player_index);	}	while (!(GET_GAME_OPTIONS()&_overhead_map_is_omniscient) && local_player->team!=player->team);		if (current_player_index!=player_index)	{		set_current_player_index(player_index);		update_interface(NONE);		dirty_terminal_view(player_index); /* In case they are in terminal mode.. */	}		return;}void initialize_players(	void){	short i;		/* no players */	dynamic_world->player_count= 0;		/* reset the action flag queues and zero the player slots */	for (i=0;i<MAXIMUM_NUMBER_OF_PLAYERS;++i)	{		memset(players+i, 0, sizeof(struct player_data));		action_queues[i].read_index= action_queues[i].write_index= 0;	}		return;}/* This will be called by entering map for two reasons: * 1) get rid of crap typed between levels, by accident. * 2) loading a game doesn't currently reset the player queues, so garbage will cause lags. *//* The above comment is stale.  Now loading map calls this and so does new_game. Calling this *//*  from entering map would bone us. */void reset_player_queues(	void){	short i;	for (i=0;i<MAXIMUM_NUMBER_OF_PLAYERS;++i)	{		action_queues[i].read_index= action_queues[i].write_index= 0;	}	reset_recording_and_playback_queues();	sync_heartbeat_count(); //•• MY ADDITION...}/* queue an action flag on the given player’s queue (no zombies allowed) */void queue_action_flags(	short player_index,	long *action_flags,	short count){	struct player_data *player= get_player_data(player_index);	struct action_queue *queue= action_queues+player_index;	assert(!PLAYER_IS_ZOMBIE(player));	while ((count-= 1)>=0)	{		queue->buffer[queue->write_index]= *action_flags++;		queue->write_index= (queue->write_index+1)&ACTION_QUEUE_BUFFER_INDEX_MASK;		if (queue->write_index==queue->read_index) dprintf("blew player %d’s queue at %p", player_index, queue);	}	return;}/* dequeue’s a single action flag from the given queue (zombies always return zero) */long dequeue_action_flags(	short player_index){	struct player_data *player= get_player_data(player_index);	struct action_queue *queue= action_queues+player_index;	long action_flags;	if (PLAYER_IS_ZOMBIE(player))	{dprintf("Player is zombie!", player_index);		action_flags= 0;	}	else	{		assert(queue->read_index!=queue->write_index);		action_flags= queue->buffer[queue->read_index];		queue->read_index= (queue->read_index+1)&ACTION_QUEUE_BUFFER_INDEX_MASK;	}	return action_flags;}/* returns the number of elements sitting in the given queue (zombies always return queue diameter) */short get_action_queue_size(	short player_index){	struct player_data *player= get_player_data(player_index);	struct action_queue *queue= action_queues+player_index;	short size;	if (PLAYER_IS_ZOMBIE(player))	{dprintf("PLayer %d is a zombie", player_index);		size= ACTION_QUEUE_BUFFER_DIAMETER;	}	else	{		if ((size= queue->write_index-queue->read_index)<0) size+= ACTION_QUEUE_BUFFER_DIAMETER;	}		return size;}/* assumes ∂t==1 tick */void update_players(	void){	struct player_data *player;	short player_index;	long action_flags;		for (player_index= 0, player= players; player_index<dynamic_world->player_count; ++player_index, ++player)	{		struct polygon_data *polygon= get_polygon_data(player->supporting_polygon_index);			action_flags= dequeue_action_flags(player_index);		if (PLAYER_IS_TELEPORTING(player)) action_flags= 0;				/* Deal with the terminal mode crap. */		if(player_in_terminal_mode(player_index))		{			update_player_keys_for_terminal(player_index, action_flags);			action_flags= 0;			update_player_for_terminal_mode(player_index);		}				update_player_physics_variables(player_index, action_flags);		player->invisibility_duration= FLOOR(player->invisibility_duration-1, 0);		player->invincibility_duration= FLOOR(player->invincibility_duration-1, 0);		player->infravision_duration= FLOOR(player->infravision_duration-1, 0);		player->reincarnation_delay= FLOOR(player->reincarnation_delay-1, 0);		if (player->extravision_duration)		{			if (!(player->extravision_duration-= 1))			{				if (player_index==current_player_index) start_extravision_effect(FALSE);			}		}		if ((static_world->environment_flags&_environment_vacuum) || (player->variables.flags&_HEAD_BELOW_MEDIA_BIT)) handle_player_in_vacuum(player_index, action_flags);		/* handle arbitration of the communications channel (i.e., dynamic_world->speaking_player_index) */		if ((action_flags&_microphone_button) && !PLAYER_IS_DEAD(player))		{			if (dynamic_world->speaking_player_index==NONE)			{				dynamic_world->speaking_player_index= player_index;				if (player_index==local_player_index) set_interface_microphone_recording_state(TRUE);			}		}		else		{			if (dynamic_world->speaking_player_index==player_index)			{				dynamic_world->speaking_player_index= NONE;				if (player_index==local_player_index) set_interface_microphone_recording_state(FALSE);			}		}		if (PLAYER_IS_DEAD(player))		{			/* do things dead players do (sit around and check for self-reincarnation) */			if (PLAYER_HAS_MAP_OPEN(player)) SET_PLAYER_MAP_STATUS(player, FALSE); 			if (PLAYER_IS_TOTALLY_DEAD(player) && (action_flags&_action_trigger_state) && !player->reincarnation_delay && (player->variables.action==_player_stationary||dynamic_world->player_count==1))			{				if (dynamic_world->player_count==1) set_game_state(_revert_game);				else revive_player(player_index);			}			update_player_weapons(player_index, 0);			update_action_key(player_index, FALSE);		}		else		{			/* do things live players do (get items, update weapons, check action key, breathe) */			swipe_nearby_items(player_index);			update_player_weapons(player_index, action_flags);			update_action_key(player_index, (action_flags&_action_trigger_state) ? TRUE : FALSE);			if (action_flags&_toggle_map) SET_PLAYER_MAP_STATUS(player, !PLAYER_HAS_MAP_OPEN(player));		}		update_player_teleport(player_index);		update_player_media(player_index);		set_player_shapes(player_index, TRUE);	}		return;}void damage_player(	short monster_index,	short aggressor_index,	short aggressor_type,	struct damage_definition *damage){	short player_index= monster_index_to_player_index(monster_index);	short aggressor_player_index= NONE; /* will be valid if the aggressor is a player */	struct player_data *player= get_player_data(player_index);	short damage_amount= calculate_damage(damage);	short damage_type= damage->type;	#pragma unused (aggressor_type)	if (player->invincibility_duration && damage->type!=_damage_fusion_bolt)	{		damage_type= _damage_absorbed;	}	else	{		/* record damage taken */		if (aggressor_index!=NONE)		{			struct monster_data *aggressor= get_monster_data(aggressor_index);						if (!PLAYER_IS_DEAD(player))			{				if (MONSTER_IS_PLAYER(aggressor))				{					struct player_data *agressor_player;										aggressor_player_index= monster_index_to_player_index(aggressor_index);					agressor_player= get_player_data(aggressor_player_index);					player->damage_taken[aggressor_player_index].damage+= damage_amount;					agressor_player->total_damage_given.damage+= damage_amount;				}				else				{					player->monster_damage_taken.damage+= damage_amount;				}			}		}		switch (damage->type)		{			case _damage_oxygen_drain:				if ((player->suit_oxygen-= damage_amount)<0) player->suit_oxygen= 0;				if (player_index==current_player_index) mark_oxygen_display_as_dirty();				break;						default:				/* damage the player, recording the kill if the aggressor was another player and we died */				if ((player->suit_energy-= damage_amount)<0)				{					if (damage->type!=_damage_energy_drain)					{						if (!PLAYER_IS_DEAD(player))						{							short action= (damage->type==_damage_explosion || damage->type==_damage_crushing || damage_amount>PLAYER_MAXIMUM_SUIT_ENERGY/2) ? _monster_is_dying_hard : _monster_is_dying_soft;														if (damage->type==_damage_flame) action= _monster_is_dying_flaming;							kill_player(player_index, aggressor_player_index, action);							if (aggressor_player_index!=NONE)							{								struct player_data *agressor_player= get_player_data(aggressor_player_index);																player->damage_taken[aggressor_player_index].kills+= 1;								if (aggressor_player_index != player_index)								{									agressor_player->total_damage_given.kills++;								}															}							else							{								player->monster_damage_taken.kills+= 1;							}						}												player->suit_oxygen= 0;						if (player_index==current_player_index) mark_oxygen_display_as_dirty();					}										player->suit_energy= 0;				}				break;		}	}		{		struct damage_response_definition *definition;		short i;				for (i=0,definition=damage_response_definitions;definition->type!=damage_type && i<NUMBER_OF_DAMAGE_RESPONSE_DEFINITIONS;++i,++definition);		assert(i!=NUMBER_OF_DAMAGE_RESPONSE_DEFINITIONS);				play_object_sound(player->object_index, PLAYER_IS_DEAD(player) ? definition->sound : definition->death_sound);		if (player_index==current_player_index)		{			if (definition->fade!=NONE) start_fade((definition->damage_threshhold!=NONE&&damage_amount>definition->damage_threshhold) ? (definition->fade+1) : definition->fade);			if (damage_amount) mark_shield_display_as_dirty();		}	}	if(player_in_terminal_mode(player_index))	{		abort_terminal_mode(player_index);	}	return;}short player_identifier_to_player_index(	short player_identifier){	struct player_data *player;	short player_index;		for (player_index=0;player_index<dynamic_world->player_count;++player_index)	{		player= get_player_data(player_index);				if (player->identifier==player_identifier) break;	}	assert(player_index!=dynamic_world->player_count);		return player_index;}void mark_player_collections(	boolean loading){	mark_collection(player_shapes.collection, loading);	if (dynamic_world->player_count==1&&loading) strip_collection(player_shapes.collection);	mark_weapon_collections(loading);	mark_item_collections(loading);	mark_interface_collections(loading);		return;}#ifdef DEBUGstruct player_data *get_player_data(	short player_index){	assert(player_index>=0&&player_index<dynamic_world->player_count);		return players+player_index;}#endifvoid set_local_player_index(	short player_index){	local_player_index= player_index;	local_player= get_player_data(player_index);		return;}void set_current_player_index(	short player_index){	current_player_index= player_index;	current_player= get_player_data(player_index);		return;}/* We just teleported in as it were-> recreate all the players..  */void recreate_players_for_new_level(	void){	short player_index;		for (player_index= 0; player_index<dynamic_world->player_count; ++player_index)	{		/* Recreate all of the players for the new level.. */			recreate_player(player_index);	}		return;}short monster_index_to_player_index(	short monster_index){	struct player_data *player;	short player_index;		for (player_index=0;player_index<dynamic_world->player_count;++player_index)	{		player= get_player_data(player_index);		if (player->monster_index==monster_index) break;	}	assert(player_index!=dynamic_world->player_count);		return player_index;}short get_polygon_index_supporting_player(	short monster_index){	short player_index= monster_index_to_player_index(monster_index);	struct player_data *player= get_player_data(player_index);		return player->supporting_polygon_index;}void process_player_powerup(	short player_index,	short item_index){	struct player_data *player= get_player_data(player_index);		switch (item_index)	{		case _i_invisibility_powerup:			player->invisibility_duration+= kINVISIBILITY_DURATION;			break;		case _i_invincibility_powerup:			player->invincibility_duration+= kINVINCIBILITY_DURATION;			break;				case _i_infravision_powerup:			player->infravision_duration+= kINFRAVISION_DURATION;			break;				case _i_extravision_powerup:			if (player_index==current_player_index) start_extravision_effect(TRUE);			player->extravision_duration+= kEXTRAVISION_DURATION;			break;				case _i_oxygen_powerup:			break;				case _i_energy_powerup:			break;		case _i_double_energy_powerup:			break;		case _i_triple_energy_powerup:			break;	}	return;}world_distance dead_player_minimum_polygon_height(	short polygon_index){	short player_index;	struct player_data *player;	world_distance minimum_height= 0;		for (player_index= 0, player= players; player_index<dynamic_world->player_count; ++player_index, ++player)	{		if (polygon_index==player->camera_polygon_index)		{			if (PLAYER_IS_DEAD(player)) minimum_height= DEAD_PLAYER_HEIGHT;			break;		}	}		return minimum_height;};boolean try_and_subtract_player_item(	short player_index,	short item_type){	struct player_data *player= get_player_data(player_index);	boolean found_one= FALSE;	assert(item_type>=0 && item_type<NUMBER_OF_ITEMS);	if (player->items[item_type]>=0)	{		if (!(player->items[item_type]-= 1)) player->items[item_type]= NONE;		mark_player_inventory_as_dirty(player_index, item_type);		found_one= TRUE;	}		return found_one;}/* ---------- private prototypes */static void handle_player_in_vacuum(	short player_index,	long action_flags){	struct player_data *player= get_player_data(player_index);	if (player->suit_oxygen>0)		{		short breathing_frequency;				switch (player->suit_oxygen/TICKS_PER_MINUTE)		{			case 0: breathing_frequency= TICKS_PER_MINUTE/6;			case 1: breathing_frequency= TICKS_PER_MINUTE/5;			case 2: breathing_frequency= TICKS_PER_MINUTE/4;			case 3: breathing_frequency= TICKS_PER_MINUTE/3;			default: breathing_frequency= TICKS_PER_MINUTE/2;		}		if (!(player->suit_oxygen%breathing_frequency)) play_local_sound(_snd_breathing);		if ((player->suit_oxygen+OXYGEN_WARNING_OFFSET)<OXYGEN_WARNING_LEVEL && !((player->suit_oxygen+OXYGEN_WARNING_OFFSET)%OXYGEN_WARNING_FREQUENCY)) play_local_sound(_snd_oxygen_warning);		player->suit_oxygen-= 1;		switch (dynamic_world->game_information.difficulty_level)		{			case _major_damage_level:				if (action_flags&(_left_trigger_state|_right_trigger_state)) player->suit_oxygen-= 1;			case _total_carnage_level:				if (action_flags&_run_dont_walk) player->suit_oxygen-= 1;				break;		}		if (player->suit_oxygen<=0)		{			struct damage_definition damage;						damage.flags= 0;			damage.type= _damage_suffocation;			damage.base= player->suit_energy+1;			damage.random= 0;			damage.scale= FIXED_ONE;						damage_player(player->monster_index, NONE, NONE, &damage);		}	}		return;}static void update_player_teleport(	short player_index){	struct player_data *player= get_player_data(player_index);	struct monster_data *monster= get_monster_data(player->monster_index);	struct object_data *object= get_object_data(monster->object_index);	struct polygon_data *polygon= get_polygon_data(object->polygon);	if (PLAYER_IS_TELEPORTING(player))	{		boolean changing_level= FALSE;			switch (player->teleporting_phase+= 1)		{			case PLAYER_TELEPORTING_MIDPOINT:				if(player->teleporting_destination>=0) /* Intralevel. */				{					short destination_polygon_index= player->teleporting_destination;					struct polygon_data *destination_polygon= get_polygon_data(destination_polygon_index);					struct damage_definition damage;					world_point3d destination;										/* Determine where we are going. */					*((world_point2d *)&destination)= destination_polygon->center;					destination.z= destination_polygon->floor_height;					damage.type= _damage_teleporter;					damage.base= damage.random= damage.flags= damage.scale= 0;					damage_monsters_in_radius(NONE, NONE, NONE, &destination, destination_polygon_index,						WORLD_ONE, &damage);					translate_map_object(player->object_index, &destination, destination_polygon_index);					initialize_player_physics_variables(player_index);					/* teleport in sound, at destination */					play_object_sound(player->object_index, _snd_teleport_in); 				} else { /* -level number is the interlevel */ 					short level_number= -player->teleporting_destination;										if(level_number==EPILOGUE_LEVEL_NUMBER)					{						/* Should this do something sly in cooperative play? */						set_game_state(_display_epilogue);						return;					} else {						set_game_state(_change_level);						set_change_level_destination(level_number);						changing_level= TRUE;					}				}				/* Either the player is teleporting, or everyone is. (level change) */								if (player_index==current_player_index || changing_level)				{					start_teleporting_effect(FALSE);//					start_fade(_fade_bright);				}				player->teleporting_destination= NO_TELEPORTATION_DESTINATION;				break;						case PLAYER_TELEPORTING_DURATION:				monster->action= _monster_is_moving;				SET_PLAYER_TELEPORTING_STATUS(player, FALSE);				break;		}	}	else	{		/* Note that control panels can set the teleporting destination. */		if (player->teleporting_destination!=NO_TELEPORTATION_DESTINATION ||			((polygon->type==_polygon_is_automatic_exit && calculate_level_completion_state()!=_level_unfinished) || polygon->type==_polygon_is_teleporter) &&				player->variables.position.x==player->variables.last_position.x &&				player->variables.position.y==player->variables.last_position.y &&				player->variables.position.z==player->variables.last_position.z &&				player->variables.last_direction==player->variables.direction &&				object->location.z==polygon->floor_height)		{			if(--player->delay_before_teleport<0)			{				SET_PLAYER_TELEPORTING_STATUS(player, TRUE);				player->teleporting_phase= 0;				player->delay_before_teleport= 0; /* The only function that changes this are */													/* computer terminals. */								/* They are in an automatic exit. */				if(player->teleporting_destination==NO_TELEPORTATION_DESTINATION)				{					if(polygon->type==_polygon_is_automatic_exit && calculate_level_completion_state()!=_level_unfinished)					{						/* This is an auto exit, and they are successful */						player->teleporting_destination= -polygon->permutation;					}					else					{						/* This is a simple teleporter */						player->teleporting_destination= polygon->permutation;					}				}					if(player->teleporting_destination>=0) /* simple teleport */				{					if (player_index==current_player_index) start_teleporting_effect(TRUE);					play_object_sound(player->object_index, _snd_teleport_out); /* teleport out sound */					monster->action= _monster_is_teleporting;				} else { /* Level change */					/* Everyone plays the teleporting effect out. */					start_teleporting_effect(TRUE);										/* Every players object plays the sound, and everyones monster responds. */					for(player_index= 0; player_index<dynamic_world->player_count; ++player_index)					{						player= get_player_data(player_index);						monster= get_monster_data(player->monster_index);												play_object_sound(player->object_index, _snd_teleport_out); /* teleport out sound */						monster->action= _monster_is_teleporting;					}				}			}		}	}}static void update_player_media(	short player_index){	struct player_data *player= get_player_data(player_index);	struct monster_data *monster= get_monster_data(player->monster_index);	struct object_data *object= get_object_data(monster->object_index);	struct polygon_data *polygon= get_polygon_data(object->polygon);	{		short sound_type= NONE;					if (player_index==current_player_index) set_fade_effect((player->variables.flags&_HEAD_BELOW_MEDIA_BIT) ? get_media_submerged_fade_effect(polygon->media_index) : NONE);			if (player->variables.flags&_FEET_BELOW_MEDIA_BIT)		{			struct media_data *media= get_media_data(polygon->media_index); // should be valid			world_distance current_magnitude= (player->variables.old_flags&_HEAD_BELOW_MEDIA_BIT) ? media->current_magnitude : (media->current_magnitude>>1);			world_distance external_magnitude= FIXED_TO_WORLD(GUESS_HYPOTENUSE(ABS(player->variables.external_velocity.i), ABS(player->variables.external_velocity.j)));			struct damage_definition *damage= get_media_damage(polygon->media_index, (player->variables.flags&_HEAD_BELOW_MEDIA_BIT) ? FIXED_ONE : FIXED_ONE/4);						// apply current if possible			if (!PLAYER_IS_DEAD(player) && external_magnitude<current_magnitude) accelerate_player(player->monster_index, 0, NORMALIZE_ANGLE(media->current_direction-HALF_CIRCLE), media->current_magnitude>>2);						// cause damage if possible			if (damage) damage_player(player->monster_index, NONE, NONE, damage);						// feet entering media sound			if (!(player->variables.old_flags&_FEET_BELOW_MEDIA_BIT)) sound_type= _media_snd_feet_entering;			// head entering media sound			if (!(player->variables.old_flags&_HEAD_BELOW_MEDIA_BIT) && (player->variables.flags&_HEAD_BELOW_MEDIA_BIT)) sound_type= _media_snd_head_entering;			// head leaving media sound			if (!(player->variables.flags&_HEAD_BELOW_MEDIA_BIT) && (player->variables.old_flags&_HEAD_BELOW_MEDIA_BIT)) sound_type= _media_snd_head_leaving;		}		else		{			// feet leaving media sound			if (polygon->media_index!=NONE && (player->variables.old_flags&_FEET_BELOW_MEDIA_BIT)) sound_type= _media_snd_feet_leaving;		}				if (sound_type!=NONE)		{			play_object_sound(monster->object_index, get_media_sound(polygon->media_index, sound_type));		}	}	if (player->variables.flags&_STEP_PERIOD_BIT)	{		short sound_index= NONE;				if ((player->variables.flags&_FEET_BELOW_MEDIA_BIT) && !(player->variables.flags&_HEAD_BELOW_MEDIA_BIT))		{			sound_index= get_media_sound(polygon->media_index, _media_snd_splashing);		}		else		{			/* make ordinary walking sound */		}				if (sound_index!=NONE)		{			play_object_sound(monster->object_index, sound_index);		}	}		return;}static void set_player_shapes(	short player_index,	boolean animate){	struct player_data *player= get_player_data(player_index);	struct monster_data *monster= get_monster_data(player->monster_index);	struct physics_variables *variables= &player->variables;	struct object_data *legs= get_object_data(monster->object_index);	struct object_data *torso= get_object_data(legs->parasitic_object);	shape_descriptor new_torso_shape, new_legs_shape;	short transfer_mode, transfer_period;		get_player_transfer_mode(player_index, &transfer_mode, &transfer_period);		/* if we’re not dead, handle changing shapes (if we are dead, the correct dying shape has		already been set and we just have to wait for the animation to finish) */	if (!PLAYER_IS_DEAD(player))	{		short torso_shape;		short mode, pseudo_weapon_type;				get_player_weapon_mode_and_type(player_index, &pseudo_weapon_type, &mode);		vassert(pseudo_weapon_type>=0 && pseudo_weapon_type<PLAYER_TORSO_SHAPE_COUNT, 			csprintf(temporary, "Pseudo Weapon Type out of range: %d", pseudo_weapon_type));		switch(mode)		{			case _shape_weapon_firing: torso_shape= player_shapes.firing_torsos[pseudo_weapon_type]; break;			case _shape_weapon_idle: torso_shape= player_shapes.torsos[pseudo_weapon_type]; break;			case _shape_weapon_charging: torso_shape= player_shapes.charging_torsos[pseudo_weapon_type]; break;			default: halt();		}		assert(player->variables.action>=0 && player->variables.action<NUMBER_OF_PLAYER_ACTIONS);		new_legs_shape= BUILD_DESCRIPTOR(BUILD_COLLECTION(player_shapes.collection, player->team), player_shapes.legs[player->variables.action]);		if(pseudo_weapon_type==_weapon_ball)		{			short color= find_player_ball_color(player_index);			/* Use the balls color for the torso.. */			new_torso_shape= BUILD_DESCRIPTOR(BUILD_COLLECTION(player_shapes.collection, color), torso_shape);		} else {			new_torso_shape= BUILD_DESCRIPTOR(BUILD_COLLECTION(player_shapes.collection, player->color), torso_shape);		}		/* stuff in the transfer modes */		if (legs->transfer_mode!=transfer_mode) legs->transfer_mode= transfer_mode, legs->transfer_period= transfer_period, legs->transfer_phase= 0;		if (torso->transfer_mode!=transfer_mode) torso->transfer_mode= transfer_mode, torso->transfer_period= transfer_period, torso->transfer_phase= 0;				/* stuff in new shapes only if they have changed (and reset phases if they have) */		if (new_legs_shape!= legs->shape) legs->shape= new_legs_shape, legs->sequence= 0;		if (new_torso_shape!=torso->shape) torso->shape= new_torso_shape, torso->sequence= 0;	}		if (animate)	{		/* animate the player only if we’re not airborne and not totally dead */		if (variables->action!=_player_airborne&&!PLAYER_IS_TOTALLY_DEAD(player)) animate_object(monster->object_index);		if (PLAYER_IS_DEAD(player) && !PLAYER_IS_TELEPORTING(player) && (GET_OBJECT_ANIMATION_FLAGS(legs)&_obj_last_frame_animated) && !PLAYER_IS_TOTALLY_DEAD(player))		{			/* we’ve finished the animation; let the player reincarnate if he wants to */			SET_PLAYER_TOTALLY_DEAD_STATUS(player, TRUE);			set_player_dead_shape(player_index, FALSE);		}	}	return;}/* We can rebuild him!! */static void revive_player(	short player_index){	struct player_data *player= get_player_data(player_index);	struct monster_data *monster= get_monster_data(player->monster_index);	struct object_location location;	struct object_data *object;	short team;	/* Figure out where the player starts */	team= calculate_player_team(player->team);	get_random_player_starting_location_and_facing(dynamic_world->player_count, team, &location);	monster->action= _monster_is_moving; /* was probably _dying or something */	/* remove only the player’s torso, which should be invisible anyway, and turn his legs		into garbage */	remove_parasitic_object(monster->object_index);	turn_object_to_shit(monster->object_index);	/* create a new pair of legs, and (completely behind MONSTERS.C’s back) reattach it to		it’s monster (shape will be set by set_player_shapes, below) */	player->object_index= monster->object_index= new_map_object(&location, 0);	object= get_object_data(monster->object_index);	SET_OBJECT_SOLIDITY(object, TRUE);	SET_OBJECT_OWNER(object, _object_is_monster);	object->permutation= player->monster_index;		/* create a new torso (shape will be set by set_player_shapes, below) */	attach_parasitic_object(monster->object_index, 0, location.yaw);	initialize_player_physics_variables(player_index);	player->weapon_intensity_decay= 0;	player->suit_energy= PLAYER_MAXIMUM_SUIT_ENERGY;	player->suit_oxygen= PLAYER_MAXIMUM_SUIT_OXYGEN;	SET_PLAYER_DEAD_STATUS(player, FALSE);	SET_PLAYER_TOTALLY_DEAD_STATUS(player, FALSE);	SET_PLAYER_TELEPORTING_STATUS(player, FALSE);	player->invincibility_duration= 0;	player->invisibility_duration= 0;	player->infravision_duration= 0;	player->extravision_duration= 0;	player->control_panel_side_index= NONE; // not using a control panel.	/* If we burn items on death, give this player the initial stuff. */	if (GET_GAME_OPTIONS()&_burn_items_on_death) give_player_initial_items(player_index);	/* set the correct shapes and transfer mode */	set_player_shapes(player_index, FALSE);	/* Update the interface to reflect your player's changed status */	if (player_index==current_player_index) update_interface(NONE); 	return;}/* The player just changed map levels, recreate him, and all of the objects *//*  associated with him. */static void recreate_player(	short player_index){	short monster_index;	struct monster_data *monster;	struct player_data *player= get_player_data(player_index);	short placement_team;	struct object_location location;		/* Determine the location */	placement_team= calculate_player_team(player->team);	get_random_player_starting_location_and_facing(player_index, placement_team, &location);	/* create an object and a monster for this player */	monster_index= new_monster(&location, _monster_marine);	monster= get_monster_data(monster_index);	/* add our parasitic torso */	attach_parasitic_object(monster->object_index, 0, location.yaw);		/* and initialize it *///	player->flags= 0;	player->flags &= (_player_has_cheated_flag | _player_is_teleporting_flag); /* Player has cheated persists. */	player->monster_index= monster_index;	player->object_index= monster->object_index;	/* initialize_player_physics_variables sets all of these */	player->facing= player->elevation= 0;	player->location.x= player->location.y= player->location.z= 0;	player->camera_location.x= player->camera_location.y= player->camera_location.z= 0;	/* We don't change... */	/* physics_model, suit_energy, suit_oxygen, current_weapon, desired_weapon */	/* None of the weapons array data... */	/* None of the items array data.. */	/* The inventory offset/dirty flags.. */	mark_player_inventory_as_dirty(player_index, _weapon);	/* Nuke the physics */	memset(&player->variables, 0, sizeof(struct physics_variables));	/* Reset the player weapon data and the physics variable.. (after updating player_count) */	initialize_player_physics_variables(player_index);	set_player_shapes(player_index, FALSE);	player->control_panel_side_index = NONE; // not using a control panel.	initialize_player_terminal_info(player_index);	return;}static void kill_player(	short player_index,	short aggressor_player_index,	short action){	struct player_data *player= get_player_data(player_index);	struct monster_data *monster= get_monster_data(player->monster_index);	struct object_data *legs= get_object_data(monster->object_index);	struct object_data *torso= get_object_data(legs->parasitic_object);	/* discharge any of our weapons which were holding charges */	discharge_charged_weapons(player_index);	initialize_player_weapons(player_index);	/* make our legs ownerless scenery, mark our monster as dying, stuff in the right dying shape */	SET_OBJECT_OWNER(legs, _object_is_normal);	monster->action= action;	monster_died(player->monster_index);	set_player_dead_shape(player_index, TRUE);		/* make our torso invisible */	SET_OBJECT_INVISIBILITY(torso, TRUE);	/* make our player dead */	SET_PLAYER_DEAD_STATUS(player, TRUE);	/* If you had something cool, you don't anymore.. */	drop_the_ball(player_index);	if (GET_GAME_OPTIONS()&_burn_items_on_death) burn_players_items(player_index);	player->reincarnation_delay= MINIMUM_REINCARNATION_DELAY;	if (GET_GAME_OPTIONS()&_dying_is_penalized) player->reincarnation_delay+= NORMAL_REINCARNATION_DELAY;	if (aggressor_player_index==player_index && (GET_GAME_OPTIONS()&_suicide_is_penalized)) player->reincarnation_delay+= SUICIDE_REINCARNATION_DELAY;	kill_player_physics_variables(player_index);	return;}static void give_player_initial_items(	short player_index){	struct player_data *player= get_player_data(player_index);	short loop;	for(loop=0; loop<(sizeof(player_initial_start_items)/sizeof(short)); ++loop)	{		/* Get the item.. */		assert(player_initial_start_items[loop]>=0 && player_initial_start_items[loop]<NUMBER_OF_ITEMS);		if(player->items[player_initial_start_items[loop]]==NONE)		{			player->items[player_initial_start_items[loop]]= 1;		} else {			player->items[player_initial_start_items[loop]]+= 1;		}				process_new_item_for_reloading(player_index, player_initial_start_items[loop]);	}		return;}static void drop_the_ball(	short player_index){	struct player_data *player= get_player_data(player_index);	short item_type;		for (item_type= 0; item_type<NUMBER_OF_ITEMS; ++item_type)	{		short item_count= player->items[item_type];				if(item_count>0 && get_item_kind(item_type)==_ball)		{			struct object_data *object= get_object_data(player->object_index);			struct object_location location;			location.p= object->location;			location.p.z= 0;			location.polygon_index= object->polygon;			location.yaw= location.pitch= location.flags= 0;					/* Drop the ball.. */			new_item(&location, item_type);		}		player->items[item_type]= NONE;	}	mark_player_inventory_as_dirty(player_index, NONE);	return;}static void burn_players_items(	short player_index){	struct player_data *player= get_player_data(player_index);	short item_type;		for (item_type= 0; item_type<NUMBER_OF_ITEMS; ++item_type)	{		short item_count= player->items[item_type];				while ((item_count-= 1)>=0) object_was_just_destroyed(_object_is_item, item_type);		player->items[item_type]= NONE;	}	mark_player_inventory_as_dirty(player_index, NONE);	return;}static void get_player_transfer_mode(	short player_index,	short *transfer_mode,	short *transfer_period){	struct player_data *player= get_player_data(player_index);	short duration= 0;	*transfer_period= 1;	*transfer_mode= NONE;	if (PLAYER_IS_TELEPORTING(player))	{		*transfer_mode= player->teleporting_phase<PLAYER_TELEPORTING_MIDPOINT ? _xfer_fold_out : _xfer_fold_in;		*transfer_period= PLAYER_TELEPORTING_MIDPOINT+1;	}	else	{		if (player->invincibility_duration) 		{			*transfer_mode= _xfer_static;			duration= player->invincibility_duration;		}		else		{			if (player->invisibility_duration) 			{				*transfer_mode= player->invisibility_duration>kINVISIBILITY_DURATION ? _xfer_subtle_invisibility : _xfer_invisibility;				duration= player->invisibility_duration;			}		}				if (duration && duration<10*TICKS_PER_SECOND)		{			switch (duration/(TICKS_PER_SECOND/6))			{				case 46: case 37: case 29: case 22: case 16: case 11: case 7: case 4: case 2:					*transfer_mode= (player->invincibility_duration && player->invisibility_duration) ?						(player->invisibility_duration>kINVISIBILITY_DURATION ? _xfer_subtle_invisibility : _xfer_invisibility) : NONE;					break;			}		}	}		return;}static void set_player_dead_shape(	short player_index,	boolean dying){	struct player_data *player= get_player_data(player_index);	struct monster_data *monster= get_monster_data(player->monster_index);	short shape;		if (monster->action==_monster_is_dying_flaming)	{		shape= dying ? FLAMING_DYING_SHAPE : FLAMING_DEAD_SHAPE;	}	else	{		if (dying)		{			shape= (monster->action==_monster_is_dying_hard) ? player_shapes.dying_hard : player_shapes.dying_soft;		}		else		{			shape= (monster->action==_monster_is_dying_hard) ? player_shapes.dead_hard : player_shapes.dead_soft;		}			shape= BUILD_DESCRIPTOR(BUILD_COLLECTION(player_shapes.collection, player->team), shape);	}	if (dying)	{		set_object_shape_and_transfer_mode(monster->object_index, shape, NONE);	}	else	{		randomize_object_sequence(monster->object_index, shape);	}		return;}static short calculate_player_team(	short base_team){	short team;	/* Starting locations are based on the team type. */	switch(GET_GAME_TYPE())	{		case _game_of_kill_monsters:		case _game_of_cooperative_play:		case _game_of_tag:		case _game_of_king_of_the_hill:		case _game_of_kill_man_with_ball:			team= NONE;			break;		case _game_of_defense:		case _game_of_rugby:								case _game_of_capture_the_flag:			team= base_team;			break;	}		return team;}	#if 0#define DECODE_ONLY#include "macintosh_cseries.h"#include "serial_numbers.c"#include "network.h"#include "shell.h"#include "projectiles.h"#include "preferences.h"extern short alien_projectile_override, human_projectile_override;static serial_number_validity_check(	void){	short i, j;	boolean found_duplicate= FALSE;	boolean found_illegal= FALSE;		dprintf("serial number checking.....................................................;g;");	//	if (preferences->last_time_ran<0xab1747dc || preferences->last_time_ran>0xab553918)	{		for (i= 0; i<dynamic_world->player_count; ++i)		{			byte *player1_long_serial_number= game_is_networked ? ((struct player_info *)NetGetPlayerData(i))->long_serial_number : serial_preferences->long_serial_number;			byte short_serial_number[BYTES_PER_SHORT_SERIAL_NUMBER];			byte inferred_pad[BYTES_PER_SHORT_SERIAL_NUMBER];						if (game_is_networked)			{				for (j= i+1; j<dynamic_world->player_count; ++j)				{					struct player_info *player2= NetGetPlayerData(j);					short k;										for (k= 0; k<10 && player1_long_serial_number[k]==player2->long_serial_number[k]; ++k);					if (k==10) found_duplicate= TRUE;				}			}						long_serial_number_to_short_serial_number_and_pad(player1_long_serial_number, short_serial_number, inferred_pad);			if (!PADS_ARE_EQUAL(inferred_pad, actual_pad) || !VALID_INVERSE_SEQUENCE(short_serial_number) ||				(!game_is_networked && ((char)short_serial_number[2])<0))			{				found_illegal= TRUE;			}			dprintf("player #%d (%08x%08x%04x) %d %d;g;", i, *(long*)player1_long_serial_number,				*(long*)(player1_long_serial_number+4), *(short*)(player1_long_serial_number+8),				found_duplicate, found_illegal);		}	}	if (found_illegal || found_duplicate) alien_projectile_override= _projectile_rocket, human_projectile_override= _projectile_rifle_bullet;		return;}#endif