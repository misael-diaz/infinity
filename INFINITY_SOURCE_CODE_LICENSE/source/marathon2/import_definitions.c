/*IMPORT_DEFINITIONS.CSunday, October 2, 1994 1:25:23 PM  (Jason')*/#include "cseries.h"#include <string.h>#include "tags.h"#include "map.h"#include "interface.h"#include "game_wad.h"#include "wad.h"#include "game_errors.h"/* ---------- globals */#define DONT_COMPILE_DEFINITIONS#include "monsters.h"#include "monster_definitions.h"#include "projectiles.h"#include "projectile_definitions.h"#include "effects.h"#include "effect_definitions.h"#include "weapons.h"#include "weapon_definitions.h"#include "physics_models.h"/* sadly extern'ed from their respective files */extern byte monster_definitions[];extern byte projectile_definitions[];extern byte effect_definitions[];extern byte weapon_definitions[];extern byte physics_models[];#define INCLUDE_STRUCTURES#include "extensions.h"/* ---------- local globals */static FileDesc physics_file;/* ---------- local prototype */static struct wad_data *get_physics_wad_data(boolean *bungie_physics);/* ---------- code */void set_physics_file(	FileDesc *file){	memcpy(&physics_file, file, sizeof(FileDesc));		return;}void set_to_default_physics_file(	void){	get_default_physics_spec(&physics_file);//	dprintf("Set to: %d %d %P", physics_file.vRefNum, physics_file.parID, physics_file.name);	return;}void import_definition_structures(	void){	struct wad_data *wad;	boolean bungie_physics;	static boolean warned_about_physics= FALSE;	wad= get_physics_wad_data(&bungie_physics);	if(wad)	{		if(!bungie_physics && !warned_about_physics)		{			/* warn the user that external physics models are Bad Thingª */			alert_user(infoError, strERRORS, warningExternalPhysicsModel, 0);			warned_about_physics= TRUE;		}				/* Actually load it in.. */				import_physics_wad_data(wad);				free_wad(wad);	}	return;}void *get_network_physics_buffer(	long *physics_length){	void *data= get_flat_data((FileDesc *) &physics_file, FALSE, 0);		if(data)	{		*physics_length= get_flat_data_length(data);	} else {		*physics_length= 0;	}		return data;}void process_network_physics_model(	void *data){	if(data)	{		struct wad_header header;		struct wad_data *wad;		boolean success= FALSE;			wad= inflate_flat_data(data, &header);		if(wad)		{			import_physics_wad_data(wad);			free_wad(wad); /* Note that the flat data points into the wad. */		}	}		return;}void import_physics_wad_data(	struct wad_data *wad){	short index;		for(index= 0; index<NUMBER_OF_DEFINITIONS; ++index)	{		long length;		struct definition_data *definition= definitions+index;		void *data;					/* Given a wad, extract the given tag from it */		data= extract_type_from_wad(wad, definition->tag, &length);		if(data)		{			/* Copy it into the proper array */			memcpy(definition->data, data, length);		}	}		return;}void *get_physics_array_and_size(	long tag, 	long *size){	short index;	void *array;	*size= 0;		for(index= 0; index<NUMBER_OF_DEFINITIONS; ++index)	{		struct definition_data *definition= definitions+index;		if(definition->tag==tag)		{			array= definition->data;			*size= definition->count*definition->size;		}	}	assert(array);		return array;}/* --------- local code */static struct wad_data *get_physics_wad_data(	boolean *bungie_physics){	struct wad_data *wad= NULL;	fileref file_id;	//	dprintf("Open is: %d %d %P", physics_file.vRefNum, physics_file.parID, physics_file.name);	file_id= open_wad_file_for_reading(&physics_file);	if(file_id != NONE)	{		struct wad_header header;		if(read_wad_header(file_id, &header))		{			if(header.data_version==BUNGIE_PHYSICS_DATA_VERSION || header.data_version==PHYSICS_DATA_VERSION)			{				wad= read_indexed_wad_from_file(file_id, &header, 0, TRUE);				if(header.data_version==BUNGIE_PHYSICS_DATA_VERSION)				{					*bungie_physics= TRUE;				} else {					*bungie_physics= FALSE;				}			}		}		close_wad_file(file_id);	} 		/* Reset any errors that might have occurred.. */	set_game_error(systemError, errNone	);	return wad;}