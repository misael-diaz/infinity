;NETWORK_LISTENER.A;Sunday, June 26, 1994 2:46:52 PM;Thursday, June 30, 1994 11:10:19 PM;  To get this to work right (due to forward referencing and poor manuals) I stuck everything;  into one procedure. a bit ugly, but i couldn't get the forward referencing to work any other;  way. i also got rid of the stuff to have multiple buffers, since socket listeners aren't;  reentrant (ajr)					machine	mc68020					string	c					include				'traps.a'					include				'appletalk.a'					include				'cseries.a'buffer_in_use		equ		$8000PacketBuffer		record	0inUse				ds.w	1protocolType		ds.b	1	;DDP protocol typedestinationNode		ds.b	1	;destination node (us or 255, presumably)sourceAddress		ds.l	1	;source address in AddrBlock formathops				ds.w	1	;hop countdatagramSize		ds.w	1	;length of datagramdatagramData		ds.b	ddpMaxData					endr;socket listener globalsTheSocketListener	proc	export					bra.s	start	;branch over the globals to the initializer					; globals stuck in the procedure. we need to have them before we use them, yet we don't; want to stick them at the beginning of the file because then they will be stuck at the; beginning of the code resource that we create, which will be problematic for calling ; these routines.packet_buffer		dc.l	0	;packet buffer pointersapplication_a5		dc.l	0	;caller’s a5old_a5				dc.l	0	;saved a5 value on entry to the socket listenerpacket_handler_proc	dc.l	0	;pointer to the function which handles packets;					symbol	NetDDPSocketListenerHeader;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; socket listener initializer;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ProcPtr NetInitializeSocketListener(void (*packet_handler_proc)(PacketBufferPtr packet), PacketBufferPtr packet_buffer);					with	PacketBuffer;remember the caller’s a5start				lea		application_a5,a0					move.l	a5,(a0)					;save the packet handler procedure, the packet buffer pointer and the number of valid;packet buffers					lea		packet_handler_proc,a0					move.l	4(a7),(a0)					lea		packet_buffer,a0					move.l	8(a7),(a0)					;mark our buffer as not in use					move.l	packet_buffer,a0					clr.w	inUse(a0)					lea		NetDDPSocketListener, a0 ;; return the address 					move.l	a0, d0					rts;					symbol	NetDDPInitializeSocketListener					endwith;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; the actual socket listener;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;NetDDPSocketListener					with	PacketBuffer;get a pointer to our PacketBuffer					move.l	packet_buffer,a3					tas		inUse(a3)					beq.s	read_packet;if this _Debugger is ever triggered it means our socket listener was re-entered.;  this is bad.					_Debugger;; so read the packet and exit without clearing the flag. may be temporary code					move.l	d1,d3					;read the rest of the packet					lea		datagramData(a3),a3		;into .datagramData					jsr		2(a4)					;call ReadRest					rtsread_packet;read the rest of the packet into .datagramData field of PacketBuffer;					move	SR, -(a7);					ori.w	#$0700, SR					move.l	d1,d3					;read the rest of the packet					lea		datagramData(a3),a3		;into .datagramData					jsr		2(a4)					;call ReadRest					bne.s	return_to_caller_PACKET_BUFFER		equ		a0_MPP_LOCALS			equ		a2_HOP_COUNT			equ		d0_DATAGRAM_LENGTH	equ		d1_SOURCE_ADDRESS		equ		d2;get a pointer to our PacketBuffer					move.l	packet_buffer, _PACKET_BUFFER;get the hop count					move.w	toRHA+lapHdSz+ddpLength(_MPP_LOCALS),_HOP_COUNT					andi.w	#DDPHopsMask,_HOP_COUNT					lsr.w	#2,_HOP_COUNT					lsr.w	#8,_HOP_COUNT					move.w	_HOP_COUNT,hops(_PACKET_BUFFER);get the datagram length (including header)					move.w	toRHA+lapHdSz+ddpLength(_MPP_LOCALS),_DATAGRAM_LENGTH					andi.w	#ddpLenMask,_DATAGRAM_LENGTH;is this a long or a short header?					move.b	toRHA+lapType(_MPP_LOCALS),d3					cmpi.b	#shortDDP,d3					beq.s	process_short_header;------------------ process long headerprocess_long_header;get protocol type and destination node					move.b	toRHA+lapHdSz+ddpType(_MPP_LOCALS),protocolType(_PACKET_BUFFER)					move.b	toRHA+lapHdSz+ddpDstNode(_MPP_LOCALS),destinationNode(_PACKET_BUFFER);build the source AddrBlock (sort of on the sly)					move.l	toRHA+lapHdSz+ddpSrcNet(_MPP_LOCALS),_SOURCE_ADDRESS					lsl.w	#8,_SOURCE_ADDRESS					move.b	toRHA+lapHdSz+ddpSrcSkt(_MPP_LOCALS),_SOURCE_ADDRESS;adjust _DATAGRAM_LENGTH to not include the header					sub.w	#ddpType+1,_DATAGRAM_LENGTH					bra.s	call_packet_handler;------------------ process short headerprocess_short_header					move.b	toRHA+lapHdSz+sddpType(_MPP_LOCALS),protocolType(_PACKET_BUFFER)					move.b	toRHA+lapDstAdr(_MPP_LOCALS),destinationNode(_PACKET_BUFFER);build the source AddrBlock (network is always zero for short headers)					moveq	#0,_SOURCE_ADDRESS					move.b	toRHA+lapSrcAdr(_MPP_LOCALS),_SOURCE_ADDRESS					lsl.w	#8,_SOURCE_ADDRESS					move.b	toRHA+lapHdSz+sddpSrcSkt(_MPP_LOCALS),_SOURCE_ADDRESS;adjust _DATAGRAM_LENGTH to not include the header					sub.w	#sddpType+1,_DATAGRAM_LENGTHcall_packet_handler;save _DATAGRAM_LENGTH and _SOURCE_ADDRESS					move.l	_SOURCE_ADDRESS,sourceAddress(_PACKET_BUFFER)					move.w	_DATAGRAM_LENGTH,datagramSize(_PACKET_BUFFER);save current a5, instantiate application a5					lea		old_a5,a3					move.l	a5,(a3)					move.l	application_a5,a5;push the address of our packet buffer onto the stack and call the packet handler					move.l	_PACKET_BUFFER,-(sp)					move.l	packet_handler_proc,a3					jsr		(a3)					addq	#4,sp;restore old a5					move.l	old_a5,a5return_to_caller;clear semaphore and return to caller					move.l	packet_buffer, a3					clr.w	inUse(a3);					move 	(a7)+, SR					rts;					symbol	NetDDPSocketListener					endwith					endproc					end